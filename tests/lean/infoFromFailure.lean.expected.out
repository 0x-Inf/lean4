[Elab.step] #check foo "hello"
foo "hello" : String × String
[Elab.step] expected type: <not-available>, term
foo "hello"
[Elab.step] 
  [Elab.app.args] explicit: false, B.foo : {α : Type} → α → α × α
  [Elab.step] expected type: ?m, term
  "hello"
  [Elab.step] 
  [Meta.isDefEq] 
    [Meta.isDefEq.step] String =?= ?m
    [Meta.isDefEq.step] 
      [Meta.isDefEq] String [nonassignable] =?= ?m [assignable]
      [Meta.isDefEq.assign] 
        [Meta.isDefEq.assign] ?m := String
        [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := String
        [Meta.isDefEq.assign.checkTypes] 
          [Meta.isDefEq.step] Type =?= Type
          [Meta.isDefEq.step] 
          [Meta.isDefEq.assign.final] ?m := String
    [Meta.isDefEq] String =?= String ... success
  [Elab.app.finalize] B.foo "hello"
  [Elab.app.finalize] after etaArgs, B.foo "hello" : String × String
  [Elab.app.args] explicit: false, A.foo : {α : Type} → [inst : HasAdd α] → α → α × α
  [Elab.step] expected type: ?m, term
  "hello"
  [Elab.step] 
  [Meta.isDefEq] 
    [Meta.isDefEq.step] String =?= ?m
    [Meta.isDefEq.step] 
      [Meta.isDefEq] String [nonassignable] =?= ?m [assignable]
      [Meta.isDefEq.assign] 
        [Meta.isDefEq.assign] ?m := String
        [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := String
        [Meta.isDefEq.assign.checkTypes] 
          [Meta.isDefEq.step] Type =?= Type
          [Meta.isDefEq.step] 
          [Meta.isDefEq.assign.final] ?m := String
    [Meta.isDefEq] String =?= String ... success
  [Elab.app.finalize] A.foo "hello"
  [Elab.app.finalize] after etaArgs, A.foo "hello" : String × String
  [Meta.synthInstance] HasAdd String ==> HasAdd String
  [Meta.synthInstance] 
    [Meta.synthInstance] main goal HasAdd String
    [Meta.synthInstance.newSubgoal] HasAdd String
    [Meta.synthInstance.globalInstances] HasAdd String #[]
    [Meta.synthInstance] remaining fuel 999
    [Meta.synthInstance] failed
[Elab.step] theorem ex : foo true = (true, true) :=
rfl
[Elab.step] expected type: Sort _, term
foo true = (true, true)
[Elab.step] 
  [Elab.step] expected type: Sort _, term
  Eq✝ (foo true) (true, true)
  [Elab.step] 
    [Elab.app.args] explicit: false, Eq : {α : Sort _} → α → α → Prop
    [Elab.app.propagateExpectedType] etaArgs.size: 0, numRemainingArgs: 2, fType: ?m → ?m → Prop
    [Elab.step] expected type: ?m, term
    foo true
    [Elab.step] 
      [Elab.app.args] explicit: false, B.foo : {α : Type} → α → α × α
      [Elab.app.propagateExpectedType] etaArgs.size: 0, numRemainingArgs: 1, fType: ?m → ?m × ?m
      [Elab.app.propagateExpectedType] ?m =?= ?m × ?m
      [Meta.isDefEq] 
        [Meta.isDefEq.step] ?m =?= ?m × ?m
        [Meta.isDefEq.step] 
          [Meta.isDefEq] ?m [assignable] =?= ?m × ?m [nonassignable]
          [Meta.isDefEq.assign] 
            [Meta.isDefEq.assign] ?m := ?m × ?m
            [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := ?m × ?m
            [Meta.isDefEq.assign.checkTypes] 
              [Meta.isDefEq.step] Sort _ =?= Type
              [Meta.isDefEq.step] 
              [Meta.isDefEq.assign.final] ?m := ?m × ?m
        [Meta.isDefEq] ?m × ?m =?= ?m × ?m ... success
      [Elab.step] expected type: ?m, term
      true
      [Elab.step] 
        [Elab.app.args] explicit: false, true : Bool
        [Elab.app.finalize] true
        [Elab.app.finalize] after etaArgs, true : Bool
        [Elab.app.finalize] expected type: ?m
        [Meta.isDefEq] 
          [Meta.isDefEq.step] ?m =?= Bool
          [Meta.isDefEq.step] 
            [Meta.isDefEq] ?m [assignable] =?= Bool [nonassignable]
            [Meta.isDefEq.assign] 
              [Meta.isDefEq.assign] ?m := Bool
              [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := Bool
              [Meta.isDefEq.assign.checkTypes] 
                [Meta.isDefEq.step] Type =?= Type
                [Meta.isDefEq.step] 
                [Meta.isDefEq.assign.final] ?m := Bool
          [Meta.isDefEq] Bool =?= Bool ... success
      [Meta.isDefEq] 
        [Meta.isDefEq.step] Bool =?= Bool
        [Meta.isDefEq.step] 
        [Meta.isDefEq] Bool =?= Bool ... success
      [Elab.app.finalize] B.foo true
      [Elab.app.finalize] after etaArgs, B.foo true : Bool × Bool
      [Elab.app.finalize] expected type: Bool × Bool
      [Meta.isDefEq] 
        [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
        [Meta.isDefEq.step] 
          [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
          [Meta.isDefEq.step] 
            [Meta.isDefEq.delta] 
              [Meta.isDefEq.step] Bool =?= Bool
              [Meta.isDefEq.step] 
              [Meta.isDefEq.step] Bool =?= Bool
              [Meta.isDefEq.step] 
        [Meta.isDefEq] Bool × Bool =?= Bool × Bool ... success
      [Meta.isDefEq] 
        [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
        [Meta.isDefEq.step] 
          [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
          [Meta.isDefEq.step] 
            [Meta.isDefEq.delta] 
              [Meta.isDefEq.step] Bool =?= Bool
              [Meta.isDefEq.step] 
              [Meta.isDefEq.step] Bool =?= Bool
              [Meta.isDefEq.step] 
        [Meta.isDefEq] Bool × Bool =?= Bool × Bool ... success
      [Elab.app.args] explicit: false, A.foo : {α : Type} → [inst : HasAdd α] → α → α × α
      [Elab.app.propagateExpectedType] etaArgs.size: 0, numRemainingArgs: 1, fType: ?m → ?m × ?m
      [Elab.app.propagateExpectedType] ?m =?= ?m × ?m
      [Meta.isDefEq] 
        [Meta.isDefEq.step] ?m =?= ?m × ?m
        [Meta.isDefEq.step] 
          [Meta.isDefEq] ?m [assignable] =?= ?m × ?m [nonassignable]
          [Meta.isDefEq.assign] 
            [Meta.isDefEq.assign] ?m := ?m × ?m
            [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := ?m × ?m
            [Meta.isDefEq.assign.checkTypes] 
              [Meta.isDefEq.step] Sort _ =?= Type
              [Meta.isDefEq.step] 
              [Meta.isDefEq.assign.final] ?m := ?m × ?m
        [Meta.isDefEq] ?m × ?m =?= ?m × ?m ... success
      [Elab.step] expected type: ?m, term
      true
      [Elab.step] 
        [Elab.app.args] explicit: false, true : Bool
        [Elab.app.finalize] true
        [Elab.app.finalize] after etaArgs, true : Bool
        [Elab.app.finalize] expected type: ?m
        [Meta.isDefEq] 
          [Meta.isDefEq.step] ?m =?= Bool
          [Meta.isDefEq.step] 
            [Meta.isDefEq] ?m [assignable] =?= Bool [nonassignable]
            [Meta.isDefEq.assign] 
              [Meta.isDefEq.assign] ?m := Bool
              [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := Bool
              [Meta.isDefEq.assign.checkTypes] 
                [Meta.isDefEq.step] Type =?= Type
                [Meta.isDefEq.step] 
                [Meta.isDefEq.assign.final] ?m := Bool
          [Meta.isDefEq] Bool =?= Bool ... success
      [Meta.isDefEq] 
        [Meta.isDefEq.step] Bool =?= Bool
        [Meta.isDefEq.step] 
        [Meta.isDefEq] Bool =?= Bool ... success
      [Elab.app.finalize] A.foo true
      [Elab.app.finalize] after etaArgs, A.foo true : Bool × Bool
      [Elab.app.finalize] expected type: Bool × Bool
      [Meta.isDefEq] 
        [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
        [Meta.isDefEq.step] 
          [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
          [Meta.isDefEq.step] 
            [Meta.isDefEq.delta] 
              [Meta.isDefEq.step] Bool =?= Bool
              [Meta.isDefEq.step] 
              [Meta.isDefEq.step] Bool =?= Bool
              [Meta.isDefEq.step] 
        [Meta.isDefEq] Bool × Bool =?= Bool × Bool ... success
      [Meta.synthInstance] HasAdd Bool ==> HasAdd Bool
      [Meta.synthInstance] 
        [Meta.synthInstance] main goal HasAdd Bool
        [Meta.synthInstance.newSubgoal] HasAdd Bool
        [Meta.synthInstance.globalInstances] HasAdd Bool #[]
        [Meta.synthInstance] remaining fuel 999
        [Meta.synthInstance] failed
    [Meta.isDefEq] 
      [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
      [Meta.isDefEq.step] 
        [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
        [Meta.isDefEq.step] 
          [Meta.isDefEq.delta] 
            [Meta.isDefEq.step] Bool =?= Bool
            [Meta.isDefEq.step] 
            [Meta.isDefEq.step] Bool =?= Bool
            [Meta.isDefEq.step] 
      [Meta.isDefEq] Bool × Bool =?= Bool × Bool ... success
    [Elab.step] expected type: Bool × Bool, term
    (true, true)
    [Elab.step] 
      [Elab.step] expected type: Bool × Bool, term
      Prod.mk✝ true true
      [Elab.step] 
        [Elab.app.args] explicit: false, Prod.mk : {α : Type _} → {β : Type _} → α → β → α × β
        [Elab.app.propagateExpectedType] etaArgs.size: 0, numRemainingArgs: 2, fType: ?m → ?m → ?m × ?m
        [Elab.app.propagateExpectedType] Bool × Bool =?= ?m × ?m
        [Meta.isDefEq] 
          [Meta.isDefEq.step] Bool × Bool =?= ?m × ?m
          [Meta.isDefEq.step] 
            [Meta.isDefEq.step] Bool × Bool =?= ?m × ?m
            [Meta.isDefEq.step] 
              [Meta.isDefEq.delta] 
                [Meta.isDefEq.step] Bool =?= ?m
                [Meta.isDefEq.step] 
                  [Meta.isDefEq] Bool [nonassignable] =?= ?m [assignable]
                  [Meta.isDefEq.assign] 
                    [Meta.isDefEq.assign] ?m := Bool
                    [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := Bool
                    [Meta.isDefEq.assign.checkTypes] 
                      [Meta.isDefEq.step] Type _ =?= Type
                      [Meta.isDefEq.step] 
                      [Meta.isDefEq.assign.final] ?m := Bool
                [Meta.isDefEq.step] Bool =?= ?m
                [Meta.isDefEq.step] 
                  [Meta.isDefEq] Bool [nonassignable] =?= ?m [assignable]
                  [Meta.isDefEq.assign] 
                    [Meta.isDefEq.assign] ?m := Bool
                    [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := Bool
                    [Meta.isDefEq.assign.checkTypes] 
                      [Meta.isDefEq.step] Type _ =?= Type
                      [Meta.isDefEq.step] 
                      [Meta.isDefEq.assign.final] ?m := Bool
          [Meta.isDefEq] Bool × Bool =?= Bool × Bool ... success
        [Elab.step] expected type: Bool, term
        true
        [Elab.step] 
          [Elab.app.args] explicit: false, true : Bool
          [Elab.app.finalize] true
          [Elab.app.finalize] after etaArgs, true : Bool
          [Elab.app.finalize] expected type: Bool
          [Meta.isDefEq] 
            [Meta.isDefEq.step] Bool =?= Bool
            [Meta.isDefEq.step] 
            [Meta.isDefEq] Bool =?= Bool ... success
        [Meta.isDefEq] 
          [Meta.isDefEq.step] Bool =?= Bool
          [Meta.isDefEq.step] 
          [Meta.isDefEq] Bool =?= Bool ... success
        [Elab.step] expected type: Bool, term
        true
        [Elab.step] 
          [Elab.app.args] explicit: false, true : Bool
          [Elab.app.finalize] true
          [Elab.app.finalize] after etaArgs, true : Bool
          [Elab.app.finalize] expected type: Bool
          [Meta.isDefEq] 
            [Meta.isDefEq.step] Bool =?= Bool
            [Meta.isDefEq.step] 
            [Meta.isDefEq] Bool =?= Bool ... success
        [Meta.isDefEq] 
          [Meta.isDefEq.step] Bool =?= Bool
          [Meta.isDefEq.step] 
          [Meta.isDefEq] Bool =?= Bool ... success
        [Elab.app.finalize] (true, true)
        [Elab.app.finalize] after etaArgs, (true, true) : Bool × Bool
        [Elab.app.finalize] expected type: Bool × Bool
        [Meta.isDefEq] 
          [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
          [Meta.isDefEq.step] 
            [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
            [Meta.isDefEq.step] 
              [Meta.isDefEq.delta] 
                [Meta.isDefEq.step] Bool =?= Bool
                [Meta.isDefEq.step] 
                [Meta.isDefEq.step] Bool =?= Bool
                [Meta.isDefEq.step] 
          [Meta.isDefEq] Bool × Bool =?= Bool × Bool ... success
    [Meta.isDefEq] 
      [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
      [Meta.isDefEq.step] 
        [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
        [Meta.isDefEq.step] 
          [Meta.isDefEq.delta] 
            [Meta.isDefEq.step] Bool =?= Bool
            [Meta.isDefEq.step] 
            [Meta.isDefEq.step] Bool =?= Bool
            [Meta.isDefEq.step] 
      [Meta.isDefEq] Bool × Bool =?= Bool × Bool ... success
    [Elab.app.finalize] B.foo true = (true, true)
    [Elab.app.finalize] after etaArgs, B.foo true = (true, true) : Prop
    [Elab.app.finalize] expected type: Sort _
    [Meta.isDefEq] 
      [Meta.isDefEq.step] Sort _ =?= Prop
      [Meta.isDefEq.step] 
      [Meta.isDefEq] Prop =?= Prop ... success
[Elab.step] expected type: B.foo true = (true, true), term
rfl
[Elab.step] 
  [Elab.app.args] explicit: false, rfl : {α : Sort _} → {a : α} → a = a
  [Elab.app.finalize] rfl
  [Elab.app.finalize] after etaArgs, rfl : ?m = ?m
  [Elab.app.finalize] expected type: B.foo true = (true, true)
  [Meta.isDefEq] 
    [Meta.isDefEq.step] B.foo true = (true, true) =?= ?m = ?m
    [Meta.isDefEq.step] 
      [Meta.isDefEq.delta] 
        [Meta.isDefEq.step] Bool × Bool =?= ?m
        [Meta.isDefEq.step] 
          [Meta.isDefEq] Bool × Bool [nonassignable] =?= ?m [assignable]
          [Meta.isDefEq.assign] 
            [Meta.isDefEq.assign] ?m := Bool × Bool
            [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := Bool × Bool
            [Meta.isDefEq.assign.checkTypes] 
              [Meta.isDefEq.step] Sort _ =?= Type
              [Meta.isDefEq.step] 
              [Meta.isDefEq.assign.final] ?m := Bool × Bool
        [Meta.isDefEq.step] B.foo true =?= ?m
        [Meta.isDefEq.step] 
          [Meta.isDefEq] B.foo true [nonassignable] =?= ?m [assignable]
          [Meta.isDefEq.assign] 
            [Meta.isDefEq.assign] ?m := B.foo true
            [Meta.isDefEq.assign.beforeMkLambda] ?m #[] := B.foo true
            [Meta.isDefEq.assign.checkTypes] 
              [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
              [Meta.isDefEq.step] 
              [Meta.isDefEq.assign.final] ?m := B.foo true
        [Meta.isDefEq.step] (true, true) =?= B.foo true
        [Meta.isDefEq.step] 
          [Meta.isDefEq.step] (true, true) =?= B.foo true
          [Meta.isDefEq.step] 
            [Meta.isDefEq.delta.unfoldRight] B.foo
            [Meta.isDefEq.step] (true, true) =?= (true, true)
            [Meta.isDefEq.step] 
    [Meta.isDefEq] B.foo true = (true, true) =?= B.foo true = B.foo true ... success
[Meta.isDefEq] 
  [Meta.isDefEq.step] B.foo true = B.foo true =?= B.foo true = (true, true)
  [Meta.isDefEq.step] 
    [Meta.isDefEq.delta] 
      [Meta.isDefEq.step] B.foo true =?= B.foo true
      [Meta.isDefEq.step] 
      [Meta.isDefEq.step] B.foo true =?= (true, true)
      [Meta.isDefEq.step] 
        [Meta.isDefEq.step] B.foo true =?= (true, true)
        [Meta.isDefEq.step] 
          [Meta.isDefEq.delta.unfoldLeft] B.foo
          [Meta.isDefEq.step] (true, true) =?= (true, true)
          [Meta.isDefEq.step] 
      [Meta.isDefEq.step] Bool × Bool =?= Bool × Bool
      [Meta.isDefEq.step] 
  [Meta.isDefEq] B.foo true = B.foo true =?= B.foo true = (true, true) ... success
[Elab.definition.body] ex : B.foo true = (true, true) :=
rfl
[Elab.definition.scc] [ex]
