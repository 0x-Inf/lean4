prelude 

universes u v w

@[inline]
def id {α : Sort u} (a : α) : α :=
  a 

def inline {α : Sort u} (a : α) : α :=
  a

@[inline]
def flip {α : Sort u} {β : Sort v} {φ : Sort w} (f : α → β → φ) : β → α → φ :=
  fun b a => f a b

@[inline]
def idDelta {α : Sort u} (a : α) : α :=
  a

/--Gadget for optional parameter support. -/
@[reducible]
def optParam (α : Sort u) (default : α) : Sort u :=
  α

/--Gadget for marking output parameters in type classes. -/
@[reducible]
def outParam (α : Sort u) : Sort u :=
  α

/--Auxiliary Declaration used to implement the notation (a : α) -/
@[reducible]
def typedExpr (α : Sort u) (a : α) : α :=
  a

/--Auxiliary Declaration used to implement the named patterns `x@p` -/
@[reducible]
def namedPattern {α : Sort u} (x a : α) : α :=
  a

/--Auxiliary unsafe constant used by the Compiler when erasing proofs from code. -/
unsafe axiom lcProof {α : Prop} : α

/--Auxiliary unsafe constant used by the Compiler to mark unreachable code. -/
unsafe axiom lcUnreachable {α : Sort u} : α 

set_option bootstrap.inductiveCheckResultingUniverse false in
  inductive PUnit : Sort u
    | unit : PUnit

/--An abbreviation for `PUnit.{0}`, its most common instantiation.
    This Type should be preferred over `PUnit` where possible to avoid
    unnecessary universe parameters. -/
abbrev Unit : Type :=
  PUnit

@[matchPattern]
abbrev Unit.unit : Unit :=
  PUnit.unit 

structure Thunk(α : Type u) : Type u := 
  (fn : Unit → α)

attribute [extern "lean_mk_thunk"] Thunk.mk

@[noinline, extern "lean_thunk_pure"]
protected def Thunk.pure {α : Type u} (a : α) : Thunk α :=
  ⟨fun _ => a⟩

@[noinline, extern "lean_thunk_get_own"]
protected def Thunk.get {α : Type u} (x : @&Thunk α) : α :=
  x.fn ()

@[noinline, extern "lean_thunk_map"]
protected def Thunk.map {α : Type u} {β : Type v} (f : α → β) (x : Thunk α) : Thunk β :=
  ⟨fun _ => f x.get⟩

@[noinline, extern "lean_thunk_bind"]
protected def Thunk.bind {α : Type u} {β : Type v} (x : Thunk α) (f : α → Thunk β) : Thunk β :=
  ⟨fun _ => (f x.get).get⟩

inductive True : Prop
  | intro : True 

inductive False : Prop 

inductive Empty : Type 

def Not (a : Prop) : Prop :=
  a → False 

inductive Eq {α : Sort u} (a : α) : α → Prop
  | refl{} : Eq a a 

abbrev Eq.ndrec.{u1, u2} {α : Sort u2} {a : α} {motive : α → Sort u1} (m : motive a) {b : α} (h : Eq a b) : motive b :=
  Eq.rec (motive := fun α _ => motive α) m h 

abbrev Eq.ndrecOn.{u1, u2} {α : Sort u2} {a : α} {motive : α → Sort u1} {b : α} (h : Eq a b) (m : motive a) :
  motive b :=
  Eq.ndrec m h 

init_quot 

inductive HEq {α : Sort u} (a : α) : {β : Sort u} → β → Prop
  | refl{} : HEq a a 

structure Prod(α : Type u)(β : Type v) := 
  (fst : α)
  (snd : β)

attribute [unbox] Prod

/--Similar to `Prod`, but `α` and `β` can be propositions.
   We use this Type internally to automatically generate the brecOn recursor. -/
structure PProd(α : Sort u)(β : Sort v) := 
  (fst : α)
  (snd : β)

/--Similar to `Prod`, but `α` and `β` are in the same universe. -/
structure MProd(α β : Type u) := 
  (fst : α)
  (snd : β)

structure And(a b : Prop) : Prop := intro :: 
  (left : a)
  (right : b)

structure Iff(a b : Prop) : Prop := intro :: 
  (mp : a → b)
  (mpr : b → a)

@[matchPattern]
def rfl {α : Sort u} {a : α} : a = a :=
  Eq.refl a 

theorem Eq.subst {α : Sort u} {motive : α → Prop} {a b : α} (h₁ : a = b) (h₂ : motive a) : motive b :=
  Eq.ndrec h₂ h₁ 

theorem Eq.trans {α : Sort u} {a b c : α} (h₁ : a = b) (h₂ : b = c) : a = c :=
  h₂ ▸ h₁ 

theorem Eq.symm {α : Sort u} {a b : α} (h : a = b) : b = a :=
  h ▸ rfl

@[macroInline]
def cast {α β : Sort u} (h : α = β) (a : α) : β :=
  Eq.rec (motive := fun α _ => α) a h

@[matchPattern]
def HEq.rfl {α : Sort u} {a : α} : a ≅ a :=
  HEq.refl a 

theorem eqOfHEq {α : Sort u} {a a' : α} (h : a ≅ a') : a = a' :=
  by 
    have (α β : Sort u) → (a : α) → (b : β) → a ≅ b → (h : α = β) → cast h a = b by 
      intro α β a b h₁ h₂ 
      induction h₁ 
      exact rfl 
    show cast rfl a = a' 
    exact this α α a a' h rfl 

inductive Sum (α : Type u) (β : Type v)
  | inl (val : α) : Sum α β
  | inr (val : β) : Sum α β 

inductive PSum (α : Sort u) (β : Sort v)
  | inl (val : α) : PSum α β
  | inr (val : β) : PSum α β 

inductive Or (a b : Prop) : Prop
  | inl (h : a) : Or a b
  | inr (h : b) : Or a b 

structure Sigma{α : Type u}(β : α → Type v) := mk :: 
  (fst : α)
  (snd : β fst)

attribute [unbox] Sigma 

structure PSigma{α : Sort u}(β : α → Sort v) := mk :: 
  (fst : α)
  (snd : β fst)

inductive Bool : Type
  | false : Bool
  | true : Bool 

structure Subtype{α : Sort u}(p : α → Prop) := 
  (val : α)
  (property : p val)

inductive Exists {α : Sort u} (p : α → Prop) : Prop
  | intro (w : α) (h : p w) : Exists p 

inductive ForInStep (α : Type u)
  | done : α → ForInStep α
  | yield : α → ForInStep α 

inductive DoResultPRBC (α β σ : Type u)
  | «pure» : α → σ → DoResultPRBC α β σ
  | «return» : β → σ → DoResultPRBC α β σ
  | «break» : σ → DoResultPRBC α β σ
  | «continue» : σ → DoResultPRBC α β σ 

inductive DoResultPR (α β σ : Type u)
  | «pure» : α → σ → DoResultPR α β σ
  | «return» : β → σ → DoResultPR α β σ 

inductive DoResultBC (σ : Type u)
  | «break» : σ → DoResultBC σ
  | «continue» : σ → DoResultBC σ 

inductive DoResultSBC (α σ : Type u)
  | «pureReturn» : α → σ → DoResultSBC α σ
  | «break» : σ → DoResultSBC α σ
  | «continue» : σ → DoResultSBC α σ 

class inductive Decidable (p : Prop)
  | isFalse (h : ¬p) : Decidable p
  | isTrue (h : p) : Decidable p 

abbrev DecidablePred {α : Sort u} (r : α → Prop) :=
  (a : α) → Decidable (r a)

abbrev DecidableRel {α : Sort u} (r : α → α → Prop) :=
  (a b : α) → Decidable (r a b)

abbrev DecidableEq (α : Sort u) :=
  (a b : α) → Decidable (a = b)

def decEq {α : Sort u} [s : DecidableEq α] (a b : α) : Decidable (a = b) :=
  s a b 

inductive Option (α : Type u)
  | none : Option α
  | some (val : α) : Option α 

attribute [unbox] Option 

export Option(none some)

export Bool(false true)

inductive List (α : Type u)
  | nil : List α
  | cons (head : α) (tail : List α) : List α 

inductive Nat
  | zero : Nat
  | succ (n : Nat) : Nat 

class OfNat(α : Type u) := 
  (ofNat : Nat → α)

export OfNat(ofNat)

instance  : OfNat Nat :=
  ⟨id⟩

axiom sorryAx (α : Sort u) (synthetic := true) : α 

class Add(α : Type u) := 
  (add : α → α → α)

class Mul(α : Type u) := 
  (mul : α → α → α)

class Neg(α : Type u) := 
  (neg : α → α)

class Sub(α : Type u) := 
  (sub : α → α → α)

class Div(α : Type u) := 
  (div : α → α → α)

class Mod(α : Type u) := 
  (mod : α → α → α)

class ModN(α : Type u) := 
  (modn : α → Nat → α)

class HasLessEq(α : Type u) := 
  (LessEq : α → α → Prop)

class HasLess(α : Type u) := 
  (Less : α → α → Prop)

class BEq(α : Type u) := 
  (beq : α → α → Bool)

class Append(α : Type u) := 
  (append : α → α → α)

class OrElse(α : Type u) := 
  (orElse : α → α → α)

class AndThen(α : Type u) := 
  (andThen : α → α → α)

class HasEquiv(α : Sort u) := 
  (Equiv : α → α → Prop)

class EmptyCollection(α : Type u) := 
  (emptyCollection : α)

class Pow(α : Type u)(β : Type v) := 
  (pow : α → β → α)

export HasLess(Less)

export HasLessEq(LessEq)

@[reducible]
def GreaterEq {α : Type u} [HasLessEq α] (a b : α) : Prop :=
  LessEq b a

@[reducible]
def Greater {α : Type u} [HasLess α] (a b : α) : Prop :=
  Less b a 

set_option bootstrap.gen_matcher_code false in
  @[extern "lean_nat_add"]
  protected def Nat.add : (@&Nat) → (@&Nat) → Nat
  | a, Nat.zero => a
  | a, Nat.succ b => Nat.succ (Nat.add a b)

attribute [matchPattern] Nat.add Add.add Neg.neg 

instance  : Add Nat :=
  ⟨Nat.add⟩

def std.priority.default : Nat :=
  1000

def std.priority.max : Nat :=
  0xFFFFFFFF

protected def Nat.prio :=
  std.priority.default + 100

def std.prec.max : Nat :=
  1024

def std.prec.arrow : Nat :=
  25

structure Task(α : Type u) : Type u := pure :: 
  (get : α)

attribute [extern "lean_task_pure"] Task.pure 

attribute [extern "lean_task_get_own"] Task.get 

namespace Task

/--Task priority. Tasks with higher priority will always be scheduled before ones with lower priority. -/
abbrev Priority :=
  Nat 

def Priority.default : Priority :=
  0

def Priority.max : Priority :=
  8

/--Any priority higher than `Task.Priority.max` will result in the task being scheduled immediately on a dedicated thread.
  This is particularly useful for long-running and/or I/O-bound tasks since Lean will by default allocate no more
  non-dedicated workers than the number of cores to reduce context switches. -/
def Priority.dedicated : Priority :=
  9

@[noinline, extern "lean_task_spawn"]
protected def spawn {α : Type u} (fn : Unit → α) (prio := Priority.default) : Task α :=
  ⟨fn ()⟩

@[noinline, extern "lean_task_map"]
protected def map {α : Type u} {β : Type v} (f : α → β) (x : Task α) (prio := Priority.default) : Task β :=
  ⟨f x.get⟩

@[noinline, extern "lean_task_bind"]
protected def bind {α : Type u} {β : Type v} (x : Task α) (f : α → Task β) (prio := Priority.default) : Task β :=
  ⟨(f x.get).get⟩

end Task 

structure NonScalar := 
  (val : Nat)

inductive PNonScalar : Type u
  | mk (v : Nat) : PNonScalar 

theorem natAddZero (n : Nat) : n + 0 = n :=
  rfl 

theorem optParamEq (α : Sort u) (default : α) : optParam α default = α :=
  rfl

/--Like `by applyInstance`, but not dependent on the tactic framework. -/
@[reducible]
def inferInstance {α : Type u} [i : α] : α :=
  i

@[reducible]
def inferInstanceAs (α : Type u) [i : α] : α :=
  i

@[macroInline]
def cond {a : Type u} : Bool → a → a → a
| true, x, y => x
| false, x, y => y

@[macroInline]
def or : Bool → Bool → Bool
| true, _ => true
| false, b => b

@[macroInline]
def and : Bool → Bool → Bool
| false, _ => false
| true, b => b

@[macroInline]
def not : Bool → Bool
| true => false
| false => true

@[macroInline]
def xor : Bool → Bool → Bool
| true, b => not b
| false, b => b

@[extern c inline "#1 || #2"]
def strictOr (b₁ b₂ : Bool) :=
  b₁ || b₂

@[extern c inline "#1 && #2"]
def strictAnd (b₁ b₂ : Bool) :=
  b₁ && b₂

@[inline]
def bne {α : Type u} [BEq α] (a b : α) : Bool :=
  !(a == b)

def implies (a b : Prop) :=
  a → b 

theorem implies.trans {p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r :=
  fun hp => h₂ (h₁ hp)

def trivial : True :=
  ⟨⟩

@[macroInline]
def False.elim {C : Sort u} (h : False) : C :=
  False.rec (fun _ => C) h

@[macroInline]
def absurd {a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a) : b :=
  False.elim (h₂ h₁)

theorem mt {a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a :=
  fun ha => h₂ (h₁ ha)

theorem notFalse : ¬False :=
  id 

theorem proofIrrel {a : Prop} (h₁ h₂ : a) : h₁ = h₂ :=
  rfl 

theorem id.def {α : Sort u} (a : α) : id a = a :=
  rfl

@[macroInline]
def Eq.mp {α β : Sort u} (h : α = β) (a : α) : β :=
  h ▸ a

@[macroInline]
def Eq.mpr {α β : Sort u} (h : α = β) (b : β) : α :=
  h ▸ b 

theorem Eq.substr {α : Sort u} {p : α → Prop} {a b : α} (h₁ : b = a) (h₂ : p a) : p b :=
  h₁ ▸ h₂ 

theorem congr {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α} (h₁ : f₁ = f₂) (h₂ : a₁ = a₂) : f₁ a₁ = f₂ a₂ :=
  h₁ ▸ h₂ ▸ rfl 

theorem congrFun {α : Sort u} {β : α → Sort v} {f g : ∀  x, β x} (h : f = g) (a : α) : f a = g a :=
  h ▸ rfl 

theorem congrArg {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂ :=
  congr rfl h 

theorem castEq {α : Sort u} (h : α = α) (a : α) : cast h a = a :=
  rfl

@[reducible]
def Ne {α : Sort u} (a b : α) :=
  ¬(a = b)

section Ne 

variable{α : Sort u}

variables{a b : α}{p : Prop}

theorem Ne.intro (h : a = b → False) : a ≠ b :=
  h 

theorem Ne.elim (h : a ≠ b) : a = b → False :=
  h 

theorem Ne.irrefl (h : a ≠ a) : False :=
  h rfl 

theorem Ne.symm (h : a ≠ b) : b ≠ a :=
  fun h₁ => h (h₁.symm)

theorem falseOfNe : a ≠ a → False :=
  Ne.irrefl 

theorem neFalseOfSelf : p → p ≠ False :=
  fun (hp : p) (h : p = False) => h ▸ hp 

theorem neTrueOfNot : ¬p → p ≠ True :=
  fun (hnp : ¬p) (h : p = True) =>
    have ¬True from h ▸ hnp 
    this trivial 

theorem trueNeFalse : ¬True = False :=
  neFalseOfSelf trivial 

end Ne 

theorem eqFalseOfNeTrue : ∀  {b : Bool}, b ≠ true → b = false
| true, h => False.elim (h rfl)
| false, h => rfl 

theorem eqTrueOfNeFalse : ∀  {b : Bool}, b ≠ false → b = true
| true, h => rfl
| false, h => False.elim (h rfl)

theorem neFalseOfEqTrue : ∀  {b : Bool}, b = true → b ≠ false
| true, _ => fun h => Bool.noConfusion h
| false, h => Bool.noConfusion h 

theorem neTrueOfEqFalse : ∀  {b : Bool}, b = false → b ≠ true
| true, h => Bool.noConfusion h
| false, _ => fun h => Bool.noConfusion h 

section 

variables{α β φ : Sort u}{a a' : α}{b b' : β}{c : φ}

theorem HEq.ndrec.{u1, u2} {α : Sort u2} {a : α} {motive : {β : Sort u2} → β → Sort u1} (m : motive a) {β : Sort u2}
  {b : β} (h : a ≅ b) : motive b :=
  @HEq.rec α a (fun b _ => motive b) m β b h 

theorem HEq.ndrecOn.{u1, u2} {α : Sort u2} {a : α} {motive : {β : Sort u2} → β → Sort u1} {β : Sort u2} {b : β}
  (h : a ≅ b) (m : motive a) : motive b :=
  @HEq.rec α a (fun b _ => motive b) m β b h 

theorem HEq.elim {α : Sort u} {a : α} {p : α → Sort v} {b : α} (h₁ : a ≅ b) (h₂ : p a) : p b :=
  eqOfHEq h₁ ▸ h₂ 

theorem HEq.subst {p : (T : Sort u) → T → Prop} (h₁ : a ≅ b) (h₂ : p α a) : p β b :=
  HEq.ndrecOn h₁ h₂ 

theorem HEq.symm (h : a ≅ b) : b ≅ a :=
  HEq.ndrecOn (motive := fun x => x ≅ a) h (HEq.refl a)

theorem heqOfEq (h : a = a') : a ≅ a' :=
  Eq.subst h (HEq.refl a)

theorem HEq.trans (h₁ : a ≅ b) (h₂ : b ≅ c) : a ≅ c :=
  HEq.subst h₂ h₁ 

theorem heqOfHEqOfEq (h₁ : a ≅ b) (h₂ : b = b') : a ≅ b' :=
  HEq.trans h₁ (heqOfEq h₂)

theorem heqOfEqOfHEq (h₁ : a = a') (h₂ : a' ≅ b) : a ≅ b :=
  HEq.trans (heqOfEq h₁) h₂ 

def typeEqOfHEq (h : a ≅ b) : α = β :=
  HEq.ndrecOn (motive := @fun (x : Sort u) _ => α = x) h (Eq.refl α)

end 

theorem eqRecHEq {α : Sort u} {φ : α → Sort v} :
  {a a' : α} → (h : a = a') → (p : φ a) → (Eq.recOn (motive := fun x _ => φ x) h p) ≅ p
| a, _, rfl, p => HEq.refl p 

theorem heqOfEqRecEq {α β : Sort u} {a : α} {b : β} (h₁ : α = β) (h₂ : Eq.rec (motive := fun α _ => α) a h₁ = b) :
  a ≅ b :=
  by 
    subst h₁ 
    apply heqOfEq 
    exact h₂ 
    done 

theorem castHEq : ∀  {α β : Sort u} (h : α = β) (a : α), cast h a ≅ a
| α, _, rfl, a => HEq.refl a 

variables{a b c d : Prop}

theorem iffIffImpliesAndImplies (a b : Prop) : (a ↔ b) ↔ (a → b) ∧ (b → a) :=
  Iff.intro (fun h => And.intro h.mp h.mpr) (fun h => Iff.intro h.left h.right)

theorem Iff.refl (a : Prop) : a ↔ a :=
  Iff.intro (fun h => h) (fun h => h)

theorem Iff.rfl {a : Prop} : a ↔ a :=
  Iff.refl a 

theorem Iff.trans (h₁ : a ↔ b) (h₂ : b ↔ c) : a ↔ c :=
  Iff.intro (fun ha => Iff.mp h₂ (Iff.mp h₁ ha)) (fun hc => Iff.mpr h₁ (Iff.mpr h₂ hc))

theorem Iff.symm (h : a ↔ b) : b ↔ a :=
  Iff.intro (Iff.mpr h) (Iff.mp h)

theorem Iff.comm : (a ↔ b) ↔ (b ↔ a) :=
  Iff.intro Iff.symm Iff.symm 

theorem Exists.elim {α : Sort u} {p : α → Prop} {b : Prop} (h₁ : Exists (fun x => p x)) (h₂ : ∀  (a : α), p a → b) :
  b :=
  h₂ h₁.1 h₁.2

@[inlineIfReduce, nospecialize]
def Decidable.decide (p : Prop) [h : Decidable p] : Bool :=
  Decidable.casesOn (motive := fun _ => Bool) h (fun _ => false) (fun _ => true)

export Decidable(isTrue isFalse decide)

instance  {α : Type u} [DecidableEq α] : BEq α :=
  ⟨fun a b => decide (a = b)⟩

theorem decideTrueEqTrue (h : Decidable True) : @decide True h = true :=
  match h with 
  | isTrue h => rfl
  | isFalse h => False.elim $ h ⟨⟩

theorem decideFalseEqFalse (h : Decidable False) : @decide False h = false :=
  match h with 
  | isFalse h => rfl
  | isTrue h => False.elim h 

theorem decideEqTrue : ∀  {p : Prop} [s : Decidable p], p → decide p = true
| _, isTrue _, _ => rfl
| _, isFalse h₁, h₂ => absurd h₂ h₁ 

theorem decideEqFalse : ∀  {p : Prop} [s : Decidable p], ¬p → decide p = false
| _, isTrue h₁, h₂ => absurd h₁ h₂
| _, isFalse h, _ => rfl 

theorem ofDecideEqTrue {p : Prop} [s : Decidable p] : decide p = true → p :=
  fun h =>
    match s with 
    | isTrue h₁ => h₁
    | isFalse h₁ => absurd h (neTrueOfEqFalse (decideEqFalse h₁))

theorem ofDecideEqFalse {p : Prop} [s : Decidable p] : decide p = false → ¬p :=
  fun h =>
    match s with 
    | isTrue h₁ => absurd h (neFalseOfEqTrue (decideEqTrue h₁))
    | isFalse h₁ => h₁

/--Similar to `decide`, but uses an explicit instance -/
@[inline]
def toBoolUsing {p : Prop} (d : Decidable p) : Bool :=
  @decide p d 

theorem toBoolUsingEqTrue {p : Prop} (d : Decidable p) (h : p) : toBoolUsing d = true :=
  @decideEqTrue _ d h 

theorem ofBoolUsingEqTrue {p : Prop} {d : Decidable p} (h : toBoolUsing d = true) : p :=
  @ofDecideEqTrue _ d h 

theorem ofBoolUsingEqFalse {p : Prop} {d : Decidable p} (h : toBoolUsing d = false) : ¬p :=
  @ofDecideEqFalse _ d h 

instance  : Decidable True :=
  isTrue trivial 

instance  : Decidable False :=
  isFalse notFalse

@[macroInline]
def dite {α : Sort u} (c : Prop) [h : Decidable c] (t : c → α) (e : ¬c → α) : α :=
  Decidable.casesOn (motive := fun _ => α) h e t

@[macroInline]
def ite {α : Sort u} (c : Prop) [h : Decidable c] (t e : α) : α :=
  Decidable.casesOn (motive := fun _ => α) h (fun _ => e) (fun _ => t)

namespace Decidable 

variables{p q : Prop}

@[macroInline]
def byCases {q : Sort u} [dec : Decidable p] (h1 : p → q) (h2 : ¬p → q) : q :=
  match dec with 
  | isTrue h => h1 h
  | isFalse h => h2 h 

theorem em (p : Prop) [Decidable p] : p ∨ ¬p :=
  byCases Or.inl Or.inr 

theorem byContradiction [dec : Decidable p] (h : ¬p → False) : p :=
  byCases id (fun np => False.elim (h np))

theorem ofNotNot [Decidable p] : ¬¬p → p :=
  fun hnn => byContradiction (fun hn => absurd hn hnn)

theorem notAndIffOrNot (p q : Prop) [d₁ : Decidable p] [d₂ : Decidable q] : ¬(p ∧ q) ↔ ¬p ∨ ¬q :=
  Iff.intro
    (fun h =>
      match d₁, d₂ with 
      | isTrue h₁, isTrue h₂ => absurd (And.intro h₁ h₂) h
      | _, isFalse h₂ => Or.inr h₂
      | isFalse h₁, _ => Or.inl h₁)
    (fun (h) ⟨hp, hq⟩ =>
      match h with 
      | Or.inl h => h hp
      | Or.inr h => h hq)

end Decidable 

section 

variables{p q : Prop}

@[inline]
def decidableOfDecidableOfIff (hp : Decidable p) (h : p ↔ q) : Decidable q :=
  if hp : p then isTrue (Iff.mp h hp) else isFalse fun hq => absurd (Iff.mpr h hq) hp

@[inline]
def decidableOfDecidableOfEq (hp : Decidable p) (h : p = q) : Decidable q :=
  h ▸ hp 

end 

section 

variables{p q : Prop}

@[macroInline]
instance  [Decidable p] [Decidable q] : Decidable (p ∧ q) :=
  if hp : p then if hq : q then isTrue ⟨hp, hq⟩ else isFalse (fun h => hq (And.right h)) else
    isFalse (fun h => hp (And.left h))

@[macroInline]
instance  [Decidable p] [Decidable q] : Decidable (p ∨ q) :=
  if hp : p then isTrue (Or.inl hp) else
    if hq : q then isTrue (Or.inr hq) else
      isFalse
        fun h =>
          match h with 
          | Or.inl h => hp h
          | Or.inr h => hq h 

instance  [Decidable p] : Decidable (¬p) :=
  if hp : p then isFalse (absurd hp) else isTrue hp

@[macroInline]
instance  [Decidable p] [Decidable q] : Decidable (p → q) :=
  if hp : p then if hq : q then isTrue (fun h => hq) else isFalse (fun h => absurd (h hp) hq) else
    isTrue (fun h => absurd h hp)

instance  [Decidable p] [Decidable q] : Decidable (p ↔ q) :=
  if hp : p then if hq : q then isTrue ⟨fun _ => hq, fun _ => hp⟩ else isFalse fun h => hq (h.1 hp) else
    if hq : q then isFalse fun h => hp (h.2 hq) else isTrue ⟨fun h => absurd h hp, fun h => absurd h hq⟩

end 

@[inline]
instance  {α : Sort u} [DecidableEq α] (a b : α) : Decidable (a ≠ b) :=
  match decEq a b with 
  | isTrue h => isFalse $ fun h' => absurd h h'
  | isFalse h => isTrue h

@[inline]
instance  : DecidableEq Bool :=
  fun a b =>
    match a, b with 
    | false, false => isTrue rfl
    | false, true => isFalse fun h => Bool.noConfusion h
    | true, false => isFalse fun h => Bool.noConfusion h
    | true, true => isTrue rfl 

theorem ifPos {c : Prop} [h : Decidable c] (hc : c) {α : Sort u} {t e : α} : (ite c t e) = t :=
  match h with 
  | (isTrue hc) => rfl
  | (isFalse hnc) => absurd hc hnc 

theorem ifNeg {c : Prop} [h : Decidable c] (hnc : ¬c) {α : Sort u} {t e : α} : (ite c t e) = e :=
  match h with 
  | (isTrue hc) => absurd hc hnc
  | (isFalse hnc) => rfl 

theorem difPos {c : Prop} [h : Decidable c] (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α} : (dite c t e) = t hc :=
  match h with 
  | (isTrue hc) => rfl
  | (isFalse hnc) => absurd hc hnc 

theorem difNeg {c : Prop} [h : Decidable c] (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α} : (dite c t e) = e hnc :=
  match h with 
  | (isTrue hc) => absurd hc hnc
  | (isFalse hnc) => rfl 

theorem difEqIf (c : Prop) [h : Decidable c] {α : Sort u} (t : α) (e : α) :
  dite c (fun h => t) (fun h => e) = ite c t e :=
  match h with 
  | (isTrue hc) => rfl
  | (isFalse hnc) => rfl 

instance  {c t e : Prop} [dC : Decidable c] [dT : Decidable t] [dE : Decidable e] : Decidable (if c then t else e) :=
  match dC with 
  | (isTrue hc) => dT
  | (isFalse hc) => dE 

instance  {c : Prop} {t : c → Prop} {e : ¬c → Prop} [dC : Decidable c] [dT : ∀  h, Decidable (t h)]
  [dE : ∀  h, Decidable (e h)] : Decidable (if h : c then t h else e h) :=
  match dC with 
  | (isTrue hc) => dT hc
  | (isFalse hc) => dE hc

/--Universe lifting operation from Sort to Type -/
structure PLift(α : Sort u) : Type u := up :: 
  (down : α)

theorem PLift.upDown {α : Sort u} : ∀  (b : PLift α), up (down b) = b
| up a => rfl 

theorem PLift.downUp {α : Sort u} (a : α) : down (up a) = a :=
  rfl 

structure PointedType := 
  (type : Type u)
  (val : type)

/--Universe lifting operation -/
structure ULift.{r, s}(α : Type s) : Type (max s r) := up :: 
  (down : α)

theorem ULift.upDown {α : Type u} : ∀  (b : ULift.{v} α), up (down b) = b
| up a => rfl 

theorem ULift.downUp {α : Type u} (a : α) : down (up.{v} a) = a :=
  rfl 

class Inhabited(α : Sort u) := mk{} :: 
  (default : α)

constant arbitrary (α : Sort u) [s : Inhabited α] : α :=
  Inhabited.default 

instance  : Inhabited Prop :=
  { default := True }

instance  (α : Sort u) {β : Sort v} [Inhabited β] : Inhabited (α → β) :=
  { default := fun _ => arbitrary β }

instance  (α : Sort u) {β : α → Sort v} [(a : α) → Inhabited (β a)] : Inhabited ((a : α) → β a) :=
  { default := fun a => arbitrary (β a) }

instance  : Inhabited Bool :=
  { default := false }

instance  : Inhabited True :=
  { default := trivial }

instance  : Inhabited Nat :=
  { default := 0 }

instance  : Inhabited NonScalar :=
  { default := ⟨arbitrary _⟩ }

instance  : Inhabited PNonScalar.{u} :=
  { default := ⟨arbitrary _⟩ }

instance  : Inhabited PointedType :=
  { default := { type := PUnit, val := ⟨⟩ } }

instance  {α} [Inhabited α] : Inhabited (ForInStep α) :=
  { default := ForInStep.done (arbitrary _) }

class inductive Nonempty (α : Sort u) : Prop
  | intro (val : α) : Nonempty α 

protected def Nonempty.elim {α : Sort u} {p : Prop} (h₁ : Nonempty α) (h₂ : α → p) : p :=
  h₂ h₁.1

instance  {α : Sort u} [Inhabited α] : Nonempty α :=
  { val := arbitrary α }

theorem nonemptyOfExists {α : Sort u} {p : α → Prop} : Exists (fun x => p x) → Nonempty α
| ⟨w, h⟩ => ⟨w⟩

class inductive Subsingleton (α : Sort u) : Prop
  | intro (h : (a b : α) → a = b) : Subsingleton α 

protected def Subsingleton.elim {α : Sort u} [h : Subsingleton α] : (a b : α) → a = b :=
  match h with 
  | intro h => h 

protected def Subsingleton.helim {α β : Sort u} [h₁ : Subsingleton α] (h₂ : α = β) (a : α) (b : β) : a ≅ b :=
  by 
    subst h₂ 
    apply heqOfEq 
    apply Subsingleton.elim 

instance  (p : Prop) : Subsingleton p :=
  ⟨fun a b => proofIrrel a b⟩

instance  (p : Prop) : Subsingleton (Decidable p) :=
  Subsingleton.intro
    fun
    | (isTrue t₁) =>
      fun
      | (isTrue t₂) => proofIrrel t₁ t₂ ▸ rfl
      | (isFalse f₂) => absurd t₁ f₂
    | (isFalse f₁) =>
      fun
      | (isTrue t₂) => absurd t₂ f₁
      | (isFalse f₂) => proofIrrel f₁ f₂ ▸ rfl 

theorem recSubsingleton {p : Prop} [h : Decidable p] {h₁ : p → Sort u} {h₂ : ¬p → Sort u}
  [h₃ : ∀  (h : p), Subsingleton (h₁ h)] [h₄ : ∀  (h : ¬p), Subsingleton (h₂ h)] :
  Subsingleton (Decidable.casesOn (motive := fun _ => Sort u) h h₂ h₁) :=
  match h with 
  | (isTrue h) => h₃ h
  | (isFalse h) => h₄ h 

structure Equivalence{α : Sort u}(r : α → α → Prop) : Prop := 
  (refl : ∀  x, r x x)
  (symm : ∀  {x y}, r x y → r y x)
  (trans : ∀  {x y z}, r x y → r y z → r x z)

def emptyRelation {α : Sort u} (a₁ a₂ : α) : Prop :=
  False 

def Subrelation {α : Sort u} (q r : α → α → Prop) :=
  ∀  {x y}, q x y → r x y 

def InvImage {α : Sort u} {β : Sort v} (r : β → β → Prop) (f : α → β) : α → α → Prop :=
  fun a₁ a₂ => r (f a₁) (f a₂)

inductive TC {α : Sort u} (r : α → α → Prop) : α → α → Prop
  | base : ∀  a b, r a b → TC r a b
  | trans : ∀  a b c, TC r a b → TC r b c → TC r a c 

namespace Subtype 

def existsOfSubtype {α : Type u} {p : α → Prop} : { x // p x } → Exists (fun x => p x)
| ⟨a, h⟩ => ⟨a, h⟩

variables{α : Type u}{p : α → Prop}

protected theorem eq : ∀  {a1 a2 : { x // p x }}, val a1 = val a2 → a1 = a2
| ⟨x, h1⟩, ⟨_, _⟩, rfl => rfl 

theorem eta (a : { x // p x }) (h : p (val a)) : mk (val a) h = a :=
  by 
    cases a 
    exact rfl 

instance  {α : Type u} {p : α → Prop} {a : α} (h : p a) : Inhabited { x // p x } :=
  { default := ⟨a, h⟩ }

instance  {α : Type u} {p : α → Prop} [DecidableEq α] : DecidableEq { x : α // p x } :=
  fun ⟨a, h₁⟩ ⟨b, h₂⟩ =>
    if h : a = b then
      isTrue
        (by 
          subst h;
          exact rfl) else
      isFalse (fun h' => Subtype.noConfusion h' (fun h' => absurd h' h))

end Subtype 

section 

variables{α : Type u}{β : Type v}

instance Sum.inhabitedLeft [h : Inhabited α] : Inhabited (Sum α β) :=
  { default := Sum.inl (arbitrary α) }

instance Sum.inhabitedRight [h : Inhabited β] : Inhabited (Sum α β) :=
  { default := Sum.inr (arbitrary β) }

instance  {α : Type u} {β : Type v} [DecidableEq α] [DecidableEq β] : DecidableEq (Sum α β) :=
  fun a b =>
    match a, b with 
    | (Sum.inl a), (Sum.inl b) =>
      if h : a = b then isTrue (h ▸ rfl) else isFalse (fun h' => Sum.noConfusion h' (fun h' => absurd h' h))
    | (Sum.inr a), (Sum.inr b) =>
      if h : a = b then isTrue (h ▸ rfl) else isFalse (fun h' => Sum.noConfusion h' (fun h' => absurd h' h))
    | (Sum.inr a), (Sum.inl b) => isFalse (fun h => Sum.noConfusion h)
    | (Sum.inl a), (Sum.inr b) => isFalse (fun h => Sum.noConfusion h)

end 

section 

variables{α : Type u}{β : Type v}

instance  [Inhabited α] [Inhabited β] : Inhabited (α × β) :=
  { default := (arbitrary α, arbitrary β) }

instance  [DecidableEq α] [DecidableEq β] : DecidableEq (α × β) :=
  fun ⟨a, b⟩ ⟨a', b'⟩ =>
    match (decEq a a') with 
    | (isTrue e₁) =>
      match (decEq b b') with 
      | (isTrue e₂) => isTrue (e₁ ▸ e₂ ▸ rfl)
      | (isFalse n₂) => isFalse (fun h => Prod.noConfusion h (fun e₁' e₂' => absurd e₂' n₂))
    | (isFalse n₁) => isFalse (fun h => Prod.noConfusion h (fun e₁' e₂' => absurd e₁' n₁))

instance  [BEq α] [BEq β] : BEq (α × β) :=
  { beq := fun ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ => a₁ == a₂ && b₁ == b₂ }

instance  [HasLess α] [HasLess β] : HasLess (α × β) :=
  { Less := fun s t => s.1 < t.1 ∨ (s.1 = t.1 ∧ s.2 < t.2) }

instance prodHasDecidableLt [HasLess α] [HasLess β] [DecidableEq α] [DecidableEq β] [(a b : α) → Decidable (a < b)]
  [(a b : β) → Decidable (a < b)] : (s t : α × β) → Decidable (s < t) :=
  fun t s => inferInstanceAs (Decidable (_ ∨ _))

theorem Prod.ltDef [HasLess α] [HasLess β] (s t : α × β) : (s < t) = (s.1 < t.1 ∨ (s.1 = t.1 ∧ s.2 < t.2)) :=
  rfl 

end 

def Prod.map.{u₁, u₂, v₁, v₂} {α₁ : Type u₁} {α₂ : Type u₂} {β₁ : Type v₁} {β₂ : Type v₂} (f : α₁ → α₂) (g : β₁ → β₂) :
  α₁ × β₁ → α₂ × β₂
| (a, b) => (f a, g b)

theorem exOfPsig {α : Type u} {p : α → Prop} : (PSigma (fun x => p x)) → Exists (fun x => p x)
| ⟨x, hx⟩ => ⟨x, hx⟩

protected theorem PSigma.eta {α : Sort u} {β : α → Sort v} {a₁ a₂ : α} {b₁ : β a₁} {b₂ : β a₂} (h₁ : a₁ = a₂)
  (h₂ : Eq.ndrec b₁ h₁ = b₂) : PSigma.mk a₁ b₁ = PSigma.mk a₂ b₂ :=
  by 
    subst h₁ 
    subst h₂ 
    exact rfl 

theorem punitEq (a b : PUnit) : a = b :=
  by 
    cases a;
    cases b;
    exact rfl 

theorem punitEqPUnit (a : PUnit) : a = () :=
  punitEq a ()

instance  : Subsingleton PUnit :=
  Subsingleton.intro punitEq 

instance  : Inhabited PUnit :=
  { default := ⟨⟩ }

instance  : DecidableEq PUnit :=
  fun a b => isTrue (punitEq a b)

class Setoid(α : Sort u) := 
  (r : α → α → Prop)
  (iseqv{} : Equivalence r)

instance  {α : Sort u} [Setoid α] : HasEquiv α :=
  ⟨Setoid.r⟩

namespace Setoid 

variables{α : Sort u}[Setoid α]

theorem refl (a : α) : a ≈ a :=
  (Setoid.iseqv α).refl a 

theorem symm {a b : α} (hab : a ≈ b) : b ≈ a :=
  (Setoid.iseqv α).symm hab 

theorem trans {a b c : α} (hab : a ≈ b) (hbc : b ≈ c) : a ≈ c :=
  (Setoid.iseqv α).trans hab hbc 

end Setoid 

axiom propext {a b : Prop} : (a ↔ b) → a = b 

theorem iffSubst {a b : Prop} {p : Prop → Prop} (h₁ : a ↔ b) (h₂ : p a) : p b :=
  Eq.subst (propext h₁) h₂ 

namespace Quot 

axiom sound : ∀  {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → Quot.mk r a = Quot.mk r b 

protected theorem liftBeta {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) (c : (a b : α) → r a b → f a = f b)
  (a : α) : lift f c (Quot.mk r a) = f a :=
  rfl 

protected theorem indBeta {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop} (p : (a : α) → motive (Quot.mk r a))
  (a : α) : (ind p (Quot.mk r a) : motive (Quot.mk r a)) = p a :=
  rfl 

protected abbrev liftOn {α : Sort u} {β : Sort v} {r : α → α → Prop} (q : Quot r) (f : α → β)
  (c : (a b : α) → r a b → f a = f b) : β :=
  lift f c q 

protected theorem inductionOn {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop} (q : Quot r)
  (h : (a : α) → motive (Quot.mk r a)) : motive q :=
  ind h q 

theorem existsRep {α : Sort u} {r : α → α → Prop} (q : Quot r) : Exists (fun a => (Quot.mk r a) = q) :=
  Quot.inductionOn (motive := fun q => Exists (fun a => (Quot.mk r a) = q)) q (fun a => ⟨a, rfl⟩)

section 

variable{α : Sort u}

variable{r : α → α → Prop}

variable{motive : Quot r → Sort v}

@[reducible, macroInline]
protected def indep (f : (a : α) → motive (Quot.mk r a)) (a : α) : PSigma motive :=
  ⟨Quot.mk r a, f a⟩

protected theorem indepCoherent (f : (a : α) → motive (Quot.mk r a))
  (h : (a b : α) → (p : r a b) → Eq.ndrec (f a) (sound p) = f b) :
  (a b : α) → r a b → Quot.indep f a = Quot.indep f b :=
  fun a b e => PSigma.eta (sound e) (h a b e)

protected theorem liftIndepPr1 (f : (a : α) → motive (Quot.mk r a))
  (h : ∀  (a b : α) (p : r a b), Eq.ndrec (f a) (sound p) = f b) (q : Quot r) :
  (lift (Quot.indep f) (Quot.indepCoherent f h) q).1 = q :=
  by 
    induction q using Quot.ind 
    exact rfl 

protected abbrev rec (f : (a : α) → motive (Quot.mk r a)) (h : (a b : α) → (p : r a b) → Eq.ndrec (f a) (sound p) = f b)
  (q : Quot r) : motive q :=
  Eq.ndrecOn (Quot.liftIndepPr1 f h q) ((lift (Quot.indep f) (Quot.indepCoherent f h) q).2)

protected abbrev recOn (q : Quot r) (f : (a : α) → motive (Quot.mk r a))
  (h : (a b : α) → (p : r a b) → Eq.ndrec (f a) (sound p) = f b) : motive q :=
  Quot.rec f h q 

protected abbrev recOnSubsingleton [h : (a : α) → Subsingleton (motive (Quot.mk r a))] (q : Quot r)
  (f : (a : α) → motive (Quot.mk r a)) : motive q :=
  by 
    induction q using Quot.rec 
    apply f 
    apply Subsingleton.elim 

protected abbrev hrecOn (q : Quot r) (f : (a : α) → motive (Quot.mk r a)) (c : (a b : α) → (p : r a b) → f a ≅ f b) :
  motive q :=
  Quot.recOn q f
    fun a b p =>
      eqOfHEq $
        have p₁ : Eq.ndrec (f a) (sound p) ≅ f a := eqRecHEq (sound p) (f a)
        HEq.trans p₁ (c a b p)

end 

end Quot 

def Quotient {α : Sort u} (s : Setoid α) :=
  @Quot α Setoid.r 

namespace Quotient

@[inline]
protected def mk {α : Sort u} [s : Setoid α] (a : α) : Quotient s :=
  Quot.mk Setoid.r a 

def sound {α : Sort u} [s : Setoid α] {a b : α} : a ≈ b → Quotient.mk a = Quotient.mk b :=
  Quot.sound 

protected abbrev lift {α : Sort u} {β : Sort v} [s : Setoid α] (f : α → β) :
  ((a b : α) → a ≈ b → f a = f b) → Quotient s → β :=
  Quot.lift f 

protected theorem ind {α : Sort u} [s : Setoid α] {motive : Quotient s → Prop} :
  ((a : α) → motive (Quotient.mk a)) → (q : Quot Setoid.r) → motive q :=
  Quot.ind 

protected abbrev liftOn {α : Sort u} {β : Sort v} [s : Setoid α] (q : Quotient s) (f : α → β)
  (c : (a b : α) → a ≈ b → f a = f b) : β :=
  Quot.liftOn q f c 

protected theorem inductionOn {α : Sort u} [s : Setoid α] {motive : Quotient s → Prop} (q : Quotient s)
  (h : (a : α) → motive (Quotient.mk a)) : motive q :=
  Quot.inductionOn q h 

theorem existsRep {α : Sort u} [s : Setoid α] (q : Quotient s) : Exists (fun (a : α) => Quotient.mk a = q) :=
  Quot.existsRep q 

section 

variable{α : Sort u}

variable[s : Setoid α]

variable{motive : Quotient s → Sort v}

@[inline]
protected def rec (f : (a : α) → motive (Quotient.mk a))
  (h : (a b : α) → (p : a ≈ b) → Eq.ndrec (f a) (Quotient.sound p) = f b) (q : Quotient s) : motive q :=
  Quot.rec f h q 

protected abbrev recOn (q : Quotient s) (f : (a : α) → motive (Quotient.mk a))
  (h : (a b : α) → (p : a ≈ b) → Eq.ndrec (f a) (Quotient.sound p) = f b) : motive q :=
  Quot.recOn q f h 

protected abbrev recOnSubsingleton [h : (a : α) → Subsingleton (motive (Quotient.mk a))] (q : Quotient s)
  (f : (a : α) → motive (Quotient.mk a)) : motive q :=
  Quot.recOnSubsingleton (h := h) q f 

protected abbrev hrecOn (q : Quotient s) (f : (a : α) → motive (Quotient.mk a))
  (c : (a b : α) → (p : a ≈ b) → f a ≅ f b) : motive q :=
  Quot.hrecOn q f c 

end 

section 

universes uA uB uC 

variables{α : Sort uA}{β : Sort uB}{φ : Sort uC}

variables[s₁ : Setoid α][s₂ : Setoid β]

protected abbrev lift₂ (f : α → β → φ)
  (c : (a₁ : α) → (b₁ : β) → (a₂ : α) → (b₂ : β) → a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) (q₁ : Quotient s₁)
  (q₂ : Quotient s₂) : φ :=
  by 
    apply Quotient.lift (fun (a₁ : α) => Quotient.lift (f a₁) (fun (a b : β) => c a₁ a a₁ b (Setoid.refl a₁)) q₂) _ q₁ 
    intros 
    induction q₂ using Quotient.ind 
    apply c;
    assumption;
    apply Setoid.refl 

protected abbrev liftOn₂ (q₁ : Quotient s₁) (q₂ : Quotient s₂) (f : α → β → φ)
  (c : (a₁ : α) → (b₁ : β) → (a₂ : α) → (b₂ : β) → a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) : φ :=
  Quotient.lift₂ f c q₁ q₂ 

protected theorem ind₂ {motive : Quotient s₁ → Quotient s₂ → Prop}
  (h : (a : α) → (b : β) → motive (Quotient.mk a) (Quotient.mk b)) (q₁ : Quotient s₁) (q₂ : Quotient s₂) :
  motive q₁ q₂ :=
  by 
    induction q₁ using Quotient.ind 
    induction q₂ using Quotient.ind 
    apply h 

protected theorem inductionOn₂ {motive : Quotient s₁ → Quotient s₂ → Prop} (q₁ : Quotient s₁) (q₂ : Quotient s₂)
  (h : (a : α) → (b : β) → motive (Quotient.mk a) (Quotient.mk b)) : motive q₁ q₂ :=
  by 
    induction q₁ using Quotient.ind 
    induction q₂ using Quotient.ind 
    apply h 

protected theorem inductionOn₃ [s₃ : Setoid φ] {motive : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop}
  (q₁ : Quotient s₁) (q₂ : Quotient s₂) (q₃ : Quotient s₃)
  (h : (a : α) → (b : β) → (c : φ) → motive (Quotient.mk a) (Quotient.mk b) (Quotient.mk c)) : motive q₁ q₂ q₃ :=
  by 
    induction q₁ using Quotient.ind 
    induction q₂ using Quotient.ind 
    induction q₃ using Quotient.ind 
    apply h 

end 

section Exact 

variable{α : Sort u}

private def rel [s : Setoid α] (q₁ q₂ : Quotient s) : Prop :=
  Quotient.liftOn₂ q₁ q₂ (fun a₁ a₂ => a₁ ≈ a₂)
    (fun a₁ a₂ b₁ b₂ a₁b₁ a₂b₂ =>
      propext
        (Iff.intro (fun a₁a₂ => Setoid.trans (Setoid.symm a₁b₁) (Setoid.trans a₁a₂ a₂b₂))
          (fun b₁b₂ => Setoid.trans a₁b₁ (Setoid.trans b₁b₂ (Setoid.symm a₂b₂)))))

private theorem rel.refl [s : Setoid α] (q : Quotient s) : rel q q :=
  Quot.inductionOn (motive := fun q => rel q q) q (fun a => Setoid.refl a)

private theorem eqImpRel [s : Setoid α] {q₁ q₂ : Quotient s} : q₁ = q₂ → rel q₁ q₂ :=
  fun h => Eq.ndrecOn h (rel.refl q₁)

theorem exact [s : Setoid α] {a b : α} : Quotient.mk a = Quotient.mk b → a ≈ b :=
  fun h => eqImpRel h 

end Exact 

section 

universes uA uB uC 

variables{α : Sort uA}{β : Sort uB}

variables[s₁ : Setoid α][s₂ : Setoid β]

protected abbrev recOnSubsingleton₂ {motive : Quotient s₁ → Quotient s₂ → Sort uC}
  [s : (a : α) → (b : β) → Subsingleton (motive (Quotient.mk a) (Quotient.mk b))] (q₁ : Quotient s₁) (q₂ : Quotient s₂)
  (g : (a : α) → (b : β) → motive (Quotient.mk a) (Quotient.mk b)) : motive q₁ q₂ :=
  by 
    induction q₁ using Quot.recOnSubsingleton 
    induction q₂ using Quot.recOnSubsingleton 
    intro a;
    apply s 
    induction q₂ using Quot.recOnSubsingleton 
    intro a;
    apply s 
    apply g 

end 

end Quotient 

section 

variable{α : Type u}

variable(r : α → α → Prop)

instance  {α : Sort u} {s : Setoid α} [d : ∀  (a b : α), Decidable (a ≈ b)] : DecidableEq (Quotient s) :=
  fun (q₁ q₂ : Quotient s) =>
    Quotient.recOnSubsingleton₂ (motive := fun a b => Decidable (a = b)) q₁ q₂
      (fun a₁ a₂ =>
        match (d a₁ a₂) with 
        | (isTrue h₁) => isTrue (Quotient.sound h₁)
        | (isFalse h₂) => isFalse (fun h => absurd (Quotient.exact h) h₂))

namespace Function 

variables{α : Sort u}{β : α → Sort v}

def Equiv (f₁ f₂ : ∀  (x : α), β x) : Prop :=
  ∀  x, f₁ x = f₂ x 

protected theorem Equiv.refl (f : ∀  (x : α), β x) : Equiv f f :=
  fun x => rfl 

protected theorem Equiv.symm {f₁ f₂ : ∀  (x : α), β x} : Equiv f₁ f₂ → Equiv f₂ f₁ :=
  fun h x => Eq.symm (h x)

protected theorem Equiv.trans {f₁ f₂ f₃ : ∀  (x : α), β x} : Equiv f₁ f₂ → Equiv f₂ f₃ → Equiv f₁ f₃ :=
  fun h₁ h₂ x => Eq.trans (h₁ x) (h₂ x)

protected theorem Equiv.isEquivalence (α : Sort u) (β : α → Sort v) : Equivalence (@Function.Equiv α β) :=
  { refl := Equiv.refl, symm := Equiv.symm, trans := Equiv.trans }

end Function 

section 

open Quotient 

variables{α : Sort u}{β : α → Sort v}

@[instance]
private def funSetoid (α : Sort u) (β : α → Sort v) : Setoid (∀  (x : α), β x) :=
  Setoid.mk (@Function.Equiv α β) (Function.Equiv.isEquivalence α β)

private def extfunApp (f : Quotient $ funSetoid α β) (x : α) : β x :=
  Quot.liftOn f (fun (f : ∀  (x : α), β x) => f x) (fun f₁ f₂ h => h x)

theorem funext {f₁ f₂ : ∀  (x : α), β x} (h : ∀  x, f₁ x = f₂ x) : f₁ = f₂ :=
  by 
    show extfunApp (Quotient.mk f₁) = extfunApp (Quotient.mk f₂)
    apply congrArg 
    apply Quotient.sound 
    exact h 

end 

instance  {α : Sort u} {β : α → Sort v} [∀  a, Subsingleton (β a)] : Subsingleton (∀  a, β a) :=
  ⟨fun f₁ f₂ => funext (fun a => Subsingleton.elim (f₁ a) (f₂ a))⟩

namespace Function 

universes u₁ u₂ u₃ u₄ 

variables{α : Sort u₁}{β : Sort u₂}{φ : Sort u₃}{δ : Sort u₄}{ζ : Sort u₁}

@[inline, reducible]
def comp (f : β → φ) (g : α → β) : α → φ :=
  fun x => f (g x)

@[inline, reducible]
def const (β : Sort u₂) (a : α) : β → α :=
  fun x => a 

end Function 

def Squash (α : Type u) :=
  Quot (fun (a b : α) => True)

def Squash.mk {α : Type u} (x : α) : Squash α :=
  Quot.mk _ x 

theorem Squash.ind {α : Type u} {motive : Squash α → Prop} (h : ∀  (a : α), motive (Squash.mk a)) :
  ∀  (q : Squash α), motive q :=
  Quot.ind h

@[inline]
def Squash.lift {α β} [Subsingleton β] (s : Squash α) (f : α → β) : β :=
  Quot.lift f (fun a b _ => Subsingleton.elim _ _) s 

instance  {α} : Subsingleton (Squash α) :=
  ⟨fun a b =>
      Squash.ind (motive := fun a => a = b)
        (fun a =>
          Squash.ind (motive := fun b => Squash.mk a = b)
            (fun b =>
              show Quot.mk _ a = Quot.mk _ b by 
                apply Quot.sound;
                exact trivial)
            b)
        a⟩

namespace Lean

/--When the kernel tries to reduce a term `Lean.reduceBool c`, it will invoke the Lean interpreter to evaluate `c`.
  The kernel will not use the interpreter if `c` is not a constant.
  This feature is useful for performing proofs by reflection.

  Remark: the Lean frontend allows terms of the from `Lean.reduceBool t` where `t` is a term not containing
  free variables. The frontend automatically declares a fresh auxiliary constant `c` and replaces the term with
  `Lean.reduceBool c`. The main motivation is that the code for `t` will be pre-compiled.

  Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.
  This is extra 30k lines of code. More importantly, you will probably not be able to check your developement using
  external type checkers (e.g., Trepplein) that do not implement this feature.
  Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.
  So, you are mainly losing the capability of type checking your developement using external checkers.

  Recall that the compiler trusts the correctness of all `[implementedBy ...]` and `[extern ...]` annotations.
  If an extern function is executed, then the trusted code base will also include the implementation of the associated
  foreign function.
-/
constant reduceBool (b : Bool) : Bool :=
  b

/--Similar to `Lean.reduceBool` for closed `Nat` terms.

  Remark: we do not have plans for supporting a generic `reduceValue {α} (a : α) : α := a`.
  The main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.
  We believe `Lean.reduceBool` enables most interesting applications (e.g., proof by reflection). -/
constant reduceNat (n : Nat) : Nat :=
  n 

axiom ofReduceBool (a b : Bool) (h : reduceBool a = b) : a = b 

axiom ofReduceNat (a b : Nat) (h : reduceNat a = b) : a = b 

end Lean

