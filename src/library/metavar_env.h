/*
Copyright (c) 2013 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

Author: Leonardo de Moura
*/
#pragma once
#include <vector>
#include "environment.h"
#include "context.h"
#include "name_set.h"
#include "metavar.h"

namespace lean {
/**
   \brief Metavariable environment. It is used for solving
   unification constraints generated by expression elaborator
   module. The elaborator compute implicit arguments that were not
   provided by the user.
*/
class metavar_env {
    enum class state { Unprocessed, Processing, Processed };
    struct cell {
        expr     m_expr;
        unsigned m_ctx_size; // size of the context where the metavariable is defined
        unsigned m_find;
        unsigned m_rank;
        state    m_state;
        cell(expr const & e, unsigned ctx_size, unsigned find);
    };
    environment const & m_env;
    std::vector<cell>   m_cells;
    unsigned            m_max_depth;
    unsigned            m_depth;
    // If m_available_definitions != nullptr, then only the
    // definitions in m_available_definitions are unfolded during unification.
    name_set const *    m_available_definitions;
    bool                m_modified;
    volatile bool       m_interrupted;

    bool is_root(unsigned midx) const;
    unsigned root_midx(unsigned midx) const;
    cell & root_cell(unsigned midx);
    cell const & root_cell(unsigned midx) const;
    cell & root_cell(expr const & m);
    cell const & root_cell(expr const & m) const;
    unsigned new_rank(unsigned r1, unsigned r2);
    [[noreturn]] void failed_to_unify();
    bool is_simple_ho_match(expr const & e1, expr const & e2, context const & ctx);
    void unify_simple_ho_match(expr const & e1, expr const & e2, unsigned ctx_size, context const & ctx);
    void unify_core(expr const & e1, expr const & e2, unsigned ctx_size, context const & ctx);
    void reduce_metavars_ctx_size(expr const & s, unsigned ctx_size);
    void unify(expr const & e1, expr const & e2, unsigned ctx_size, context const & ctx);

public:
    metavar_env(environment const & env, name_set const * available_defs, unsigned max_depth);
    metavar_env(environment const & env, name_set const * available_defs);
    metavar_env(environment const & env);

    /** \brief Create a new meta-variable for a context of size ctx_sz. */
    expr mk_metavar(unsigned ctx_sz = 0);

    /**
       \brief Return true iff the given metavariable representative is
       assigned.

       \pre is_metavar(m)
    */
    bool is_assigned(expr const & m) const;

    /**
        \brief If the given expression is a metavariable, then return the root
        of the equivalence class. Otherwise, return itself.

        If the the metavariable was defined in smaller context, we lift the
        free variables to match the size of the given context.
    */
    expr root_at(expr const & m, unsigned ctx_size) const;
    expr root_at(expr const & m, context const & ctx) const {
        return root_at(m, length(ctx));
    }

    /**
       \brief Assign m <- s

       \remark s is a term that occurs in a context of size \c
       ctx_size. We need this information to adjust \c s to the
       metavariable \c m, since \c m maybe was created in context of
       different size, or was unified with another metavariable
       created in a smaller context.

       \pre is_metavar(m)

    */
    void assign(expr const & m, expr const & s, unsigned ctx_size);

    /**
       \brief Replace the metavariables occurring in \c e with the
       substitutions in this metaenvironment.
    */
    expr instantiate_metavars(expr const & e, unsigned ctx_size = 0);

    /**
        \brief Return true iff the given expression is an available
        definition.
    */
    bool is_definition(expr const & e);

    /**
       \brief Return the definition of the given expression in the
       environment m_env.
    */
    expr const & get_definition(expr const & e);

    /**
       \brief Check if \c e1 and \c e2 can be unified in the given
       metavariable environment. The environment may be updated with
       new assignments. An exception is throw if \c e1 and \c e2 can't
       be unified.
    */
    void unify(expr const & e1, expr const & e2, context const & ctx = context());

    /**
       \brief Clear/Reset the state.
    */
    void clear();

    bool modified() const { return m_modified; }
    void reset_modified() { m_modified = false; }

    void set_interrupt(bool flag);

    void display(std::ostream & out) const;
    bool check_invariant() const;
};
}
