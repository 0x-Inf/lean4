/*
Copyright (c) 2016 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

Author: Leonardo de Moura
*/
#pragma once
#include "util/name.h"
#include "util/name_generator.h"

namespace lean {
/** \brief Create a unique fresh name. This operation is thread-safe, and it guarantees the names are unique
    even when multiple threads are used and they are created using */
name mk_fresh_name();

/** \brief Create a unique fresh name prefixed with the given tag. The tag is used to mark the name.
    \pre tag.is_atomic() */
name mk_tagged_fresh_name(name const & tag);

/** \brief Return true iff \c n is tagged by atomic name \c tag */
bool is_tagged_by(name const & n, name const & tag);

optional<name> get_tagged_name_suffix(name const & n, name const & tag);

bool is_fresh_name(name const & n);
name sanitize_if_fresh(name const & n);

/* Return a snapshot of the thread local name_generator for fresh names.
   We use this operation to save the state of the fresh name_generator in the parser snapshots. */
name_generator get_fresh_name_generator_snapshot();

/* Set the thread local name_generator.

   We use this operation:
   1- to restore the state of the fresh name_generator when we restore parser snapshots.
   2- to set the fresh name_generator for a task.

   \pre \c g must have been created using `get_fresh_name_generator_snapshot` or `mk_fresh_name_generator_child`.
*/
void set_fresh_name_generator(name_generator const & g);

/* Create a new name_generator that does not create names that may conflict with names
   generated by the current thread local fresh name_generator.

   We use this operation to set the name_generator before we execute a task. */
name_generator mk_fresh_name_generator_child();

struct fresh_name_scope {
    name_generator m_old;
public:
    fresh_name_scope();
    fresh_name_scope(name_generator const & g);
    ~fresh_name_scope();
};

void initialize_fresh_name();
void finalize_fresh_name();
}
